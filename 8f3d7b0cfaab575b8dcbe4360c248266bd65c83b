{
  "comments": [
    {
      "key": {
        "uuid": "14a2a46d_a19564d9",
        "filename": "webrtc/modules/rtp_rtcp/source/rtp_header_extensions.h",
        "patchSetId": 6
      },
      "lineNbr": 150,
      "author": {
        "id": 1132136
      },
      "writtenOn": "2017-07-20T03:05:20Z",
      "side": 1,
      "message": "nit: Should say \"URI\" in comments like this (similar to MID, SDP, RTP, etc.)",
      "revId": "8f3d7b0cfaab575b8dcbe4360c248266bd65c83b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e9632c6b_fd2ec0f6",
        "filename": "webrtc/modules/rtp_rtcp/source/rtp_header_extensions.h",
        "patchSetId": 6
      },
      "lineNbr": 152,
      "author": {
        "id": 1138974
      },
      "writtenOn": "2017-07-20T08:02:35Z",
      "side": 1,
      "message": "Probably instead of this template it is simpler to have one class with Pasre/Write function, like RtpIdSerializer in patchset#3\nand then individual RtpStreamId/RepairedRtpStreamId/RtpMid with own kId/kUri constants and derive it from the RtpIdSerializer (to get Parse/Write function without redefining them, unlike in patchset#3).",
      "range": {
        "startLine": 152,
        "startChar": 30,
        "endLine": 152,
        "endChar": 0
      },
      "revId": "8f3d7b0cfaab575b8dcbe4360c248266bd65c83b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea78a926_630202ba",
        "filename": "webrtc/modules/rtp_rtcp/source/rtp_header_extensions.h",
        "patchSetId": 6
      },
      "lineNbr": 152,
      "author": {
        "id": 1228509
      },
      "writtenOn": "2017-07-20T17:41:42Z",
      "side": 1,
      "message": "Thanks for the suggestion. That looks to be the cleanest solution. I\u0027ve gone ahead and changed the code to work in that way.",
      "parentUuid": "e9632c6b_fd2ec0f6",
      "range": {
        "startLine": 152,
        "startChar": 30,
        "endLine": 152,
        "endChar": 0
      },
      "revId": "8f3d7b0cfaab575b8dcbe4360c248266bd65c83b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34e68121_5b93304e",
        "filename": "webrtc/modules/rtp_rtcp/source/rtp_header_extensions.h",
        "patchSetId": 6
      },
      "lineNbr": 160,
      "author": {
        "id": 1132136
      },
      "writtenOn": "2017-07-20T03:05:20Z",
      "side": 1,
      "message": "Wait... how does a \"static constexpr const char*\" work exactly? Does this string end up in multiple translation units or not (and is it any different than before)?",
      "revId": "8f3d7b0cfaab575b8dcbe4360c248266bd65c83b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1175184_2b26d9ce",
        "filename": "webrtc/modules/rtp_rtcp/source/rtp_header_extensions.h",
        "patchSetId": 6
      },
      "lineNbr": 160,
      "author": {
        "id": 1228509
      },
      "writtenOn": "2017-07-20T06:34:20Z",
      "side": 1,
      "message": "Admittedly I\u0027m no expert on C++ templates, but according to some internet searching it seems that C++ has special logic for handling templates in particular to ensure that only one instance of the class ends up in the final linked binary (I think the terminology is \"weak symbol\").\n\nHere\u0027s a question about it on Stack Overflow with some quotes from the standard: https://stackoverflow.com/questions/20484885/does-the-one-definition-rule-force-a-single-static-function-variable-to-be-creat",
      "parentUuid": "34e68121_5b93304e",
      "revId": "8f3d7b0cfaab575b8dcbe4360c248266bd65c83b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}