{
  "comments": [
    {
      "key": {
        "uuid": "70abe928_5c1f08e4",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy.cc",
        "patchSetId": 8
      },
      "lineNbr": 561,
      "author": {
        "id": 5150
      },
      "writtenOn": "2017-10-01T21:43:28Z",
      "side": 1,
      "message": "If we are going to serialize the events one at a time, then we could use SerializeToString or SerializeAsString instead.",
      "range": {
        "startLine": 561,
        "startChar": 15,
        "endLine": 561,
        "endChar": 29
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32b48c48_4236460f",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy.cc",
        "patchSetId": 8
      },
      "lineNbr": 561,
      "author": {
        "id": 5147
      },
      "writtenOn": "2017-10-02T09:05:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "70abe928_5c1f08e4",
      "range": {
        "startLine": 561,
        "startChar": 15,
        "endLine": 561,
        "endChar": 29
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3301ac35_5d96c89a",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 5150
      },
      "writtenOn": "2017-10-01T21:43:28Z",
      "side": 1,
      "message": "Is there any test case that actually tests multiple values in the struct?",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 15
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9212492_d13e599c",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 5147
      },
      "writtenOn": "2017-10-02T09:05:26Z",
      "side": 1,
      "message": "Ah, I forgot to add the last test - all of them together. Thanks for catching.",
      "parentUuid": "3301ac35_5d96c89a",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 15
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "037d04d1_f52df52e",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 70,
      "author": {
        "id": 5150
      },
      "writtenOn": "2017-10-01T21:43:28Z",
      "side": 1,
      "message": "If int is less than 32 bits then most of the randomness will be removed by the saturated cast. If you want to randomize an int, then it seems better to\nprng_.Rand(0, rtc::saturated_cast\u003cint32_t\u003e(std::numeric_limits\u003cint\u003e::max()));",
      "range": {
        "startLine": 70,
        "startChar": 16,
        "endLine": 70,
        "endChar": 30
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1092c50a_9c59fc0c",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 70,
      "author": {
        "id": 5147
      },
      "writtenOn": "2017-10-02T09:05:26Z",
      "side": 1,
      "message": "Rand() returns an int32_t, so we\u0027d need another cast to prevent implicit narrowing. That would leave us with:\nreturn static_cast\u003cint\u003e(prng_.Rand(0, rtc::saturated_cast\u003cint32_t\u003e(std::numeric_limits\u003cint\u003e::max())));\nAt this point, I think we can safely declare this to be overkill. :-)\nSince int-s narrower than 32 bits are highly unlikely on modern systems, let me just static_assert against that. I doubt there are any hobbyists out there trying to get WebRTC running on a SNES. If there are, let them disable these unit-tests and risk some regressions in RtcEventLog... :-)",
      "parentUuid": "037d04d1_f52df52e",
      "range": {
        "startLine": 70,
        "startChar": 16,
        "endLine": 70,
        "endChar": 30
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85591a05_8528375d",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 89,
      "author": {
        "id": 5150
      },
      "writtenOn": "2017-10-01T21:43:28Z",
      "side": 1,
      "message": "We should be able to parameterize the test by encoding type too, once we have multiple encodings.",
      "range": {
        "startLine": 89,
        "startChar": 2,
        "endLine": 89,
        "endChar": 26
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbf091ea_7b602687",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 89,
      "author": {
        "id": 5147
      },
      "writtenOn": "2017-10-02T09:05:26Z",
      "side": 1,
      "message": "Yes and no.\nYes - all of the tests here would still be relevant for the new encoding.\nNo - more tests would be necessary, because the new encoding is stateful, whereas this encoding is stateless.\nOkay, let\u0027s move this into encoder_unittests.cc, and later run the extra tests (stateful) on both encoders, even though only one would need it.",
      "parentUuid": "85591a05_8528375d",
      "range": {
        "startLine": 89,
        "startChar": 2,
        "endLine": 89,
        "endChar": 26
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8cc444b4_a38ffb4d",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 169,
      "author": {
        "id": 5150
      },
      "writtenOn": "2017-10-01T21:43:28Z",
      "side": 1,
      "message": "Shouldn\u0027t you be setting the timestamp to a random value? Same in the rest of the code.",
      "range": {
        "startLine": 169,
        "startChar": 38,
        "endLine": 169,
        "endChar": 51
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e82510f_12faff55",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 169,
      "author": {
        "id": 5147
      },
      "writtenOn": "2017-10-02T09:05:26Z",
      "side": 1,
      "message": "This has pros and cons.\nCon - a random timestamp derived of a short list of hard-coded seeds would only check encoding of a handful of timestamps, over and over again. Letting the true clock determine the timestamp means that each time the test is run, coverage is increased.\nPro - if using a true clock, we likely only test on a small segment of chronologically close timestamps.\nGiven the trade-off, I prefer to keep things as they are. (I see ways of enjoying both worlds, but I think that would be overkill.)",
      "parentUuid": "8cc444b4_a38ffb4d",
      "range": {
        "startLine": 169,
        "startChar": 38,
        "endLine": 169,
        "endChar": 51
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b4f516b_b127887e",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 512,
      "author": {
        "id": 5150
      },
      "writtenOn": "2017-10-01T21:43:28Z",
      "side": 1,
      "message": "Aren\u0027t these the seeds? Shouldn\u0027t they be a bit more \"random\"?",
      "range": {
        "startLine": 512,
        "startChar": 0,
        "endLine": 512,
        "endChar": 58
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "217fcee7_8b6fcaf3",
        "filename": "logging/rtc_event_log/encoder/rtc_event_log_encoder_legacy_unittest.cc",
        "patchSetId": 8
      },
      "lineNbr": 512,
      "author": {
        "id": 5147
      },
      "writtenOn": "2017-10-02T09:05:26Z",
      "side": 1,
      "message": "1. I chose these completely randomly; I swear.\n2. Why should we manually \"randomize\"? Do you not trust the PRNG to do a better job than us?",
      "parentUuid": "2b4f516b_b127887e",
      "range": {
        "startLine": 512,
        "startChar": 0,
        "endLine": 512,
        "endChar": 58
      },
      "revId": "2eb16908e93ecd041986bf61b1194b01ad774740",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}